
TASK 1

    Part A
                                            Status              Responsible (Karl or Andreas)          Tested
    Implement in lexer:                                     
        - Multiplication                    Finished            Karl                                   True                                    
        - Division                          Finished            Karl                                   True
        - Bool and                          Finished            Karl                                   True
        - Bool or                           Finished            Karl                                   True
        - Bool True                         Finished            Karl                                   True
        - Bool False                        Finished            Karl                                   True
        - Bool negation                     Finished            Karl                                   True
        - Int negation                      Finished            Karl                                   True


    Implement in parser:
        - Multiplication                    Finished            Karl                                   True
        - Division                          Finished            Karl                                   True
        - Bool and                          Finished            Karl                                   True
        - Bool or                           Finished            Karl                                   True
        - Bool True                         Finished            Karl                                   True
        - Bool False                        Finished            Karl                                   True
        - Bool negation                     Finished            Karl                                   True
        - Int negation                      Finished            Karl                                   True


    Implement in interpreter:
        - Multiplication                    Finished            Karl                                   True
        - Division                          Finished            Karl                                   True
        - Bool and                          Finished            Karl                                   True (But should we check both types with short circuiting. Currently don't)
        - Bool or                           Finished            Karl                                   True (But should we check both types with short circuiting. Currently don't)
        - Bool True                         Finished            Karl                                   True
        - Bool False                        Finished            Karl                                   True
        - Bool negation                     Finished            Karl                                   True
        - Int negation                      Finished            Karl                                   True


    Implement in Type checker:
        - Multiplication                    None
        - Division                          None
        - Bool and                          None
        - Bool or                           None
        - Bool True                         None
        - Bool False                        None
        - Bool negation                     None
        - Int negation                      None


    Implement in RISC-V code generator:
        - Multiplication                    None
        - Division                          None
        - Bool and                          None
        - Bool or                           None
        - Bool True                         None
        - Bool False                        None
        - Bool negation                     None
        - Int negation                      None

    Part B
    
    Implement in parser and  lexer:
        - Multiple-declaration lets         Started             Karl                                   False


TASK 2                                          

    Implement in lexer:
        - replicate                         None
        - filter                            None                Andreas
        - scan                              None                                     


    Implement in parser:
        - replicate                         None
        - filter                            None                Andreas
        - scan                              None         


    Implement in interpreter:
        - replicate                         None
        - filter                            None                Andreas
        - scan                              None         


    Implement in Type checker:
        - replicate                         None
        - filter                            None                Andreas
        - scan                              None          


    Implement in RISC-V code generator:
        - replicate                         None
        - filter                            None                Andreas
        - scan                              None           



TASK 3




TASK 4 (BONUS)





TESTING













NOTES
    - How does stronger binding / precedence occur? How to implement in Parser.fsp. Idea how early in Exp definition                     Karl 